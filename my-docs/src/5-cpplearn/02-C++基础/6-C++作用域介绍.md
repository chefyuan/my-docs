本文主要介绍下`C++`中作用域的概念。

作用域，一般可以理解为变量或函数的可见范围，不同的变量（全局变量、局部变量、静态变量）它的作用域是不同的。

而作用域大体可以分`全局作用域`、`命名空间作用域`、`类域`、`函数作用域`等。

# **全局作用域**

比较好理解，如果在一个源文件中定义了一个全局变量，那这个变量的作用域就是整个源文件。

比如：

```C++
// test.cc
int global = 1;

void func() {
  cout << global;
}

void func2() {
  cout << global;
}
```

注意这里`global`的作用域是在作用在整个源文件中，只在本文件内可访问。

而一个应用程序可以由多个源文件组成，在其他文件其实也可以访问这个`global`变量，但是不能直接访问，比如：

```C++
// test2.cc
void func() {
  cout << global;
}

void func2() {
  cout << global;
}
```

这样是不能编译通过的，这里需要在`test2.cc`中使用`extern`声明一下：

```C++
// test2.cc
extern int global;
void func() {
  cout << global;
}

void func2() {
  cout << global;
}
```

这里的`extern int global；`表示在声明一个global变量，但却不在此文件内定义，它的定义会存在于其他源文件中。

通过`extern`声明后，在`test2.cc`中就可以访问`test.cc`中的global全局变量了。

**那有没有办法定义一个全局变量，只在当前源文件内可访问，其它源文件不可见呢？**

可以，加个`static`关键字：

```C++
// test.cc
static int global = 1;
void func() {
  cout << global;
}

void func2() {
  cout << global;
}
```

`static`在这里表示局部的含义，表示只在当前源文件可见。在开发的过程中大家如果有上面的需求（只希望在源文件内可见），无论是变量还是函数，建议都使用`static`修饰。

# **命名空间作用域**

一般在`C++`中所有的变量或者函数或者类都会封装在`namespace`中：

```C++
namespace chengxumiao {
  int meow;
}

int func() {
  cout << meow;
}
```

上面的代码会报错，因为`func`根本不知道`meow`是什么，meow是在`chengxumiao`的`namespace`下，如果想访问它，有几种方式：

```C++
int func() {
    cout << chengxumiao::meow;
}
```

可以这样显式指定`chengxumiao`下的`meow`，或者：

```C++
namespace chengxumiao {
  int func() {
    cout << meow;
  }
}
```

可以这样把`func`也包裹在`chengxumiao`的`namespace`下，两者共处同一个`namespace`就可以访问了，或者：

```C++
using namespace chengxumiao;
int func() {
  cout << meow;
}
```

这样使用`using`就表示默认会去`chengxumiao`的`namespace`下找对应的变量。

# **类域**

就是只可在当前类内访问：

```C++
class A {
  int a;
  int b;

  void f() {
    cout << a;
  }
};
```

像这种就可以理解为是类域，只有当前类内的函数才可以访问当前类内的变量，其他类或者外部是不可以访问当前类的东西的。

# **函数作用域**

这块也可以理解为局部变量的作用域：

```C++
void f() {
  int a;
  cout << a;
}
```

比如在函数内定义的变量只能在当前函数内访问，其它地方是不能访问的。

注意：上面的各种概念可能和书本上的不太一样，我是本着易于理解的角度来介绍的，可能有些概念整理的不是很书面且标准。