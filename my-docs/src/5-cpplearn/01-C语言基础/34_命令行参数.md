命令行参数将从命令行中获取输入的信息，方便用户在程序运行时动态的传递信息给程序，提高灵活性。

# 基本概念

在C语言中，命令行参数通过`main`函数的参数传递给程序。`main`函数的原型可以是以下两种形式之一：

```C
int main(int argc, char *argv[]);
```

或者：

```C
int main(int argc, char **argv);
```

其中：

- `argc`（argument count）表示命令行参数的数量，包括程序名本身，因此`argc`的值至少为1。
- `argv`（argument vector）是一个指向字符串数组的指针，其中每个字符串是一个命令行参数。数组的第一个元素`argv[0]`通常是程序的名称，接下来的元素是传递给程序的命令行参数。

# 使用方法

使用命令行参数非常简单，只需要在`main`函数中声明`argc`和`argv`参数，然后根据需要访问这些参数即可。

示例代码：

```C
#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc == 1) {
        printf("No arguments supplied.\n");
    } else if (argc == 2) {
        printf("The argument supplied is %s\n", argv[1]);
    } else {
        printf("Multiple arguments supplied:\n");
        for (int i = 1; i < argc; i++) {
            printf("argv[%d] = %s\n", i, argv[i]);
        }
    }
    return 0;
}
```

# 应用场景

命令行参数在许多情况下都非常有用：

1. **配置文件路径**：程序可以根据命令行参数指定的配置文件路径来加载配置信息。
2. **模式选择**：例如，程序可能支持调试模式和正常模式，用户可以通过命令行参数来选择运行模式。
3. **输入文件和输出文件名**：程序可以根据命令行参数指定的输入文件和输出文件名来读取数据和写入结果。
4. **运行时选项和标志**：例如，`-v`标志可能表示详细模式，程序在详细模式下会输出更多的调试信息。

# 高级技巧

1. **处理带空格的参数**：

如果命令行参数本身包含空格，那么传递参数时应该将整个参数放在双引号`""`或单引号`''`内部。例如：

```Bash
$ ./a.out "arg with spaces"
```

1. **参数解析库**：

对于复杂的命令行参数解析需求，可以使用专门的参数解析库，如`getopt`。`getopt`函数提供了一个统一的接口来处理短选项（如`-a`）和长选项（如`--all`），自动处理选项参数的解析和错误检查。

以下是一个使用`getopt`的示例程序：

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int opt;
    while ((opt = getopt(argc, argv, "ab:c::")) != -1) {
        switch (opt) {
            case 'a':
                printf("Option -a was triggered.\n");
                break;
            case 'b':
                printf("Option -b with value %s\n", optarg);
                break;
            case 'c':
                printf("Option -c with optional value %s\n", optarg ? optarg : "not provided");
                break;
            case '?':
                // getopt prints an error message for unknown options
                break;
            default:
                abort();
        }
    }

    // Remaining command line arguments after options
    printf("Non-option arguments:\n");
    for (int index = optind; index < argc; index++) {
        printf("%s\n", argv[index]);
    }

    return 0;
}
```

可以传递不同的选项来观察其行为：

```Bash
$ ./a.out -a -b value -c
Option -a was triggered.
Option -b with value value
Option -c with optional value not provided
Non-option arguments:
(no non-option arguments)

$ ./a.out -b val -d
a.out: invalid option -- 'd'
Try 'a.out --help' for more information.
Option -b with value val
Non-option arguments:
(no non-option arguments)
```

注意，在这个示例中，`-d`是一个未知选项，`getopt`会自动打印错误消息。同时，`optind`变量被用来指示处理完所有选项后的第一个非选项参数的位置。