在C++编程中，内存管理是一个至关重要的概念。

要深入理解内存管理，我们肯定要了解堆内存和栈内存的基本概念、区别以及它们的动态分配和释放方法。还需要深入理解相关内存分配函数`malloc`、`calloc`、`realloc`的用法。

# 基本概念理解

## 栈内存

栈内存是由编译器自动管理的内存区域，用于存储局部变量、函数参数和返回地址等。栈内存的分配和释放是自动进行的：

- 当函数被调用时，局部变量和参数会被压入栈中；
- 当函数返回时，这些局部变量和参数会被弹出栈并释放。

栈内存具有快速分配和释放的特点，但其大小是固定的，一般也就8M左右，不能动态调整。

## 堆内存

堆内存是由程序员手动管理的内存区域，用于动态分配内存。

你通过`malloc`、`calloc`、`realloc`等函数可以在堆上分配内存，通过`free`函数释放内存。

堆内存的大小不固定，可以动态调整，但需要程序员负责内存的管理，容易出现内存泄漏等问题，我们常说的内存泄露问题指的更多的就是**堆内存**的泄露。

## 区别

- **内存****管理**：栈内存由编译器自动管理，堆内存由程序员手动管理。
- **作用域**：栈内存的作用域通常是函数内部，当函数返回时，栈内存会自动被释放；堆内存的作用域由程序员控制，只要程序员不释放，内存就会一直存在。
- **生命周期**：栈内存的生命周期与函数执行时间相关，函数执行完毕后，栈内存会被释放；堆内存的生命周期由程序员控制，直到显式调用`free`函数释放内存。

# 堆内存的使用

## 使用`malloc`动态分配空间

`malloc`函数用于在堆上分配指定大小的内存块。函数声明形式为：

```C
void* malloc(size_t size);
```

- `size`：要分配的字节数。
- 返回值：指向分配的内存块的指针，如果分配失败，返回`NULL`。

示例代码：

```C
int* ptr = (int*)malloc(sizeof(int) * 10); // 分配10个int类型的内存空间
if (ptr == NULL) {
    // 处理内存分配失败的情况
}
```

## 使用`calloc`分配并初始化内存

`calloc`函数用于在堆上分配内存并初始化为0。函数声明形式为：

```C
void* calloc(size_t num, size_t size);
```

- `num`：要分配的元素个数。
- `size`：每个元素的字节数。
- 返回值：指向分配的内存块的指针，如果分配失败，返回`NULL`。

示例代码：

```C
int* ptr = (int*)calloc(10, sizeof(int)); // 分配10个int类型的内存空间，并初始化为0
if (ptr == NULL) {
    // 处理内存分配失败的情况
}
```

## 使用`realloc`调整内存大小

`realloc`函数用于调整已分配内存块的大小。函数声明形式为：

```C
void* realloc(void* ptr, size_t size);
```

- `ptr`：指向要调整大小的内存块的指针。
- `size`：新的内存块大小（字节数）。
- 返回值：指向新的内存块的指针，如果分配失败，返回`NULL`，原内存块保持不变。

示例代码：

```C
int* ptr = (int*)malloc(sizeof(int) * 10); // 初始分配10个int类型的内存空间
if (ptr == NULL) {
    // 处理内存分配失败的情况
}

// 使用realloc调整内存大小
ptr = (int*)realloc(ptr, sizeof(int) * 20);
if (ptr == NULL) {
    // 处理内存调整失败的情况，注意原内存块仍然有效
}
```

## 使用`free`释放内存

`free`函数用于释放之前通过`malloc`、`calloc`或`realloc`分配的内存空间。函数声明形式为：

```C
void free(void* ptr);
```

- `ptr`：指向要释放的内存块的指针。

示例代码：

```C
int* ptr = (int*)malloc(sizeof(int) * 10); // 分配10个int类型的内存空间
if (ptr == NULL) {
    // 处理内存分配失败的情况
}

// 使用内存...

free(ptr); // 释放内存
ptr = NULL; // 将指针置为NULL，避免悬挂指针
```

# 栈内存与堆内存的对比

## 编程实践展示

以下示例展示了栈内存和堆内存的不同使用场景和特性：

```C
#include <stdio.h>
#include <stdlib.h>

void stackMemoryExample() {
    int stackVar = 10; // 栈内存，函数返回时自动释放
    printf("Stack variable: %d\n", stackVar);
}

void heapMemoryExample() {
    int* heapVar = (int*)malloc(sizeof(int)); // 堆内存，需要手动释放
    if (heapVar == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return;
    }
    *heapVar = 20;
    printf("Heap variable: %d\n", *heapVar);
    free(heapVar); // 释放堆内存
    heapVar = NULL; // 避免悬挂指针
}

int main() {
    stackMemoryExample(); // 调用栈内存示例函数
    heapMemoryExample();  // 调用堆内存示例函数
    return 0;
}
```

其中

`stackMemoryExample`函数使用了栈内存来存储局部变量`stackVar`，当函数返回时，`stackVar`会自动释放。

而`heapMemoryExample`函数则使用堆内存来存储变量`heapVar`，并通过`malloc`分配内存，通过`free`释放内存。

# 练习

1. 编写一个程序，动态分配一个整型数组的内存空间，用于存储用户输入的5个整数，然后遍历并打印这些整数。最后，释放分配的内存。
2. 编写一个程序，包含两个函数。第一个函数使用栈内存（局部变量）存储并打印一个整数数组；第二个函数使用堆内存动态分配并存储用户输入的整数数组，然后打印并释放内存。通过这两个函数的调用，展示栈内存和堆内存在使用上的区别。

# 进阶

1. 为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢？会不会多释放一些内存或者少释放了一些内存？
2. malloc更底层的原理是什么？一次malloc底层都经历了什么？
3. 栈内存和堆内存的区别？
4. 什么场景下使用栈，什么场景下使用堆呢？
5. 栈数组下标越界访问会发生什么？
6. 什么是栈溢出？
7. 了解下常见的栈攻击手段。